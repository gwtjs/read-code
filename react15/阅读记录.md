## 说明

源代码的阅读，以[demo代码](https://github.com/gwtjs/read-code/tree/master/react15/%E4%BE%8B%E5%AD%90/react-demo)的执行顺序进行。

react源代码地址在[这里](https://github.com/gwtjs/read-code/tree/master/react15/%E4%BE%8B%E5%AD%90/react-demo/modules)，这是经过整理、注释、去掉dev环境相关信息后的版本。

在React源码中，require()的参数都是直接写的文件名而不是相对或绝对路径，实现方式在[此处](./阅读记录/全局模块系统.md)讲解。

## 执行之前

项目入口文件index.js中的`ReactDOM.render(<App/>,document.getElementById('root'))`，首先jsx文件通过babel预设`@babel/preset-react`进行语法解析，结果为`ReactDOM.render(React.createElement(App, null),document.getElementById('root'))`。

> `@babel/preset-react`预设（preset）始终包含以下插件：
>
> - [@babel/plugin-syntax-jsx](https://www.babeljs.cn/docs/babel-plugin-syntax-jsx)
> - [@babel/plugin-transform-react-jsx](https://www.babeljs.cn/docs/babel-plugin-transform-react-jsx)
> - [@babel/plugin-transform-react-display-name](https://www.babeljs.cn/docs/babel-plugin-transform-react-display-name)
>
> 如果开启了 `development` 参数，还将包含以下插件：
>
> Classic runtime adds:
>
> - [@babel/plugin-transform-react-jsx-self](https://www.babeljs.cn/docs/babel-plugin-transform-react-jsx-self)
> - [@babel/plugin-transform-react-jsx-source](https://www.babeljs.cn/docs/babel-plugin-transform-react-jsx-source)

## 调用React.createElement

<img src="https://github.com/gwtjs/read-code/raw/master/react15/%E5%9B%BE%E7%89%87/React.createElement.svg" alt="injection"  />

最终得到带$$typeof属性的ReactElement对象，关于$$typeof的解析，在[这篇文章](./阅读记录/$$typeof.md)中。接下来看看`ReactDOM.render`的调用关系

## 调用ReactDOM.render

```javascript

// 依赖注入
ReactDefaultInjection.inject();

var render = ReactPerf.measure('React', 'render', ReactMount.render);

var React = {
  findDOMNode: findDOMNode,
  render: render,
  unmountComponentAtNode: ReactMount.unmountComponentAtNode,
  version: ReactVersion,

  /* eslint-disable camelcase */
  unstable_batchedUpdates: ReactUpdates.batchedUpdates,
  unstable_renderSubtreeIntoContainer: renderSubtreeIntoContainer
  /* eslint-enable camelcase */
};
```

这里模块执行是，先进行了[依赖注入](./阅读记录/依赖注入.md)，然后对外暴露方法，其中`render`方法实际上调用的是`ReactMount.render`方法

## 调用ReactMount.render

```javascript
var ELEMENT_NODE_TYPE = 1;
var DOC_NODE_TYPE = 9;
var DOCUMENT_FRAGMENT_NODE_TYPE = 11;
// container为div#root
function getReactRootElementInContainer(container) {
  if (!container) {
    return null;
  }
  // container为div#root,container.nodeType为1
  if (container.nodeType === DOC_NODE_TYPE) {
    return container.documentElement;
  } else {
    // container.firstChild为Null
    return container.firstChild;
  }
}
// container为div#root
function getNativeRootInstanceInContainer(container) {
  var rootEl = getReactRootElementInContainer(container);
  var prevNativeInstance =
    rootEl && ReactDOMComponentTree.getInstanceFromNode(rootEl);
  return (
    prevNativeInstance && !prevNativeInstance._nativeParent ?
    prevNativeInstance : null
  );
}
// container为div#root
function getTopLevelWrapperInContainer(container) {
  var root = getNativeRootInstanceInContainer(container);
  return root ? root._nativeContainerInfo._topLevelWrapper : null;
}

var topLevelRootCounter = 1;
var TopLevelWrapper = function() {
  this.rootID = topLevelRootCounter++;
};
TopLevelWrapper.prototype.isReactComponent = {};
if (__DEV__) {
  TopLevelWrapper.displayName = 'TopLevelWrapper';
}
TopLevelWrapper.prototype.render = function() {
  // this.props is actually a ReactElement
  return this.props;
};

var ReactMount = {
  TopLevelWrapper: TopLevelWrapper,
  // 调用ReactMount.render({$$typeof:Symbol.for('react.element'), type:App, key:null, ref:null, props:{}, _owner:null}, div#root)
  render: function(nextElement, container, callback) {
    return ReactMount._renderSubtreeIntoContainer(null, nextElement, container, callback);
  },
    
  _renderSubtreeIntoContainer: function(parentComponent, nextElement, container, callback) {
    ReactUpdateQueue.validateCallback(callback, 'ReactDOM.render');

    // 其中TopLevelWrapper定义如上，nextElement为{$$typeof:Symbol.for('react.element'), key:null, ref:null, props:{}, _owner:null}
    // 结果为{
    // 	$$typeof: Symbol.for('react.element'),
    //   type: TopLevelWrapper,
    //    key: null,
    //    ref: null,
    //    props: {$$typeof:Symbol.for('react.element'), type:App, key:null, ref:null, props:{}, _owner:null},
    //    _owner: null
  	// }
    var nextWrappedElement = ReactElement(
      TopLevelWrapper,
      null,
      null,
      null,
      null,
      null,
      nextElement
    );

    // container为div#root， 返回结果为null
    var prevComponent = getTopLevelWrapperInContainer(container);

    if (prevComponent) {
      var prevWrappedElement = prevComponent._currentElement;
      var prevElement = prevWrappedElement.props;
      if (shouldUpdateReactComponent(prevElement, nextElement)) {
        var publicInst = prevComponent._renderedComponent.getPublicInstance();
        var updatedCallback = callback && function() {
          callback.call(publicInst);
        };
        ReactMount._updateRootComponent(
          prevComponent,
          nextWrappedElement,
          container,
          updatedCallback
        );
        return publicInst;
      } else {
        ReactMount.unmountComponentAtNode(container);
      }
    }
	// 结果为null
    var reactRootElement = getReactRootElementInContainer(container);
    var containerHasReactMarkup =
      reactRootElement && !!internalGetID(reactRootElement);
    // 结果为undefined
    var containerHasNonRootReactChild = hasNonRootReactChild(container);

    var shouldReuseMarkup =
      containerHasReactMarkup &&
      !prevComponent &&
      !containerHasNonRootReactChild;
    // 调用ReactMount._renderNewRootComponent({
    //    $$typeof: Symbol.for('react.element'),
    //    type: TopLevelWrapper,
    //    key: null,
    //    ref: null,
    //    props: {$$typeof:Symbol.for('react.element'), type:App, key:null, ref:null, props:{}, _owner:null},
    //    _owner: null
  	// }, div#root, null, null)
    var component = ReactMount._renderNewRootComponent(
      nextWrappedElement,
      container,
      shouldReuseMarkup,
      parentComponent != null ?
        parentComponent._reactInternalInstance._processChildContext(
          parentComponent._reactInternalInstance._context
        ) :
        emptyObject
    )._renderedComponent.getPublicInstance();
    if (callback) {
      callback.call(component);
    }
    return component;
  },
    
  _renderNewRootComponent: function(
    nextElement,
    container,
    shouldReuseMarkup,
    context
  ) {

    ReactBrowserEventEmitter.ensureScrollValueMonitoring();
    // 调用src/renderers/shared/reconciler/instantiateReactComponent.js的instantiateReactComponent({
    //   	$$typeof: Symbol.for('react.element'),
    //     type: TopLevelWrapper,
    //     key: null,
    //     ref: null,
    //     props: {$$typeof:Symbol.for('react.element'), type:App, key:null, ref:null, props:{}, _owner:null},
    //     _owner: null
    // })
    var componentInstance = instantiateReactComponent(nextElement);
    // 返回的实例
    // {
    //   _currentElement : {
    //   	$$typeof: Symbol.for('react.element'),
    //     type: TopLevelWrapper,
    //     key: null,
    //     ref: null,
    //     props: {$$typeof:Symbol.for('react.element'), type:App, key:null, ref:null, props:{}, _owner:null},
    //     _owner: null
    // };
    // _rootNodeID : null;
    // _instance : null;
    // _nativeParent : null;
    // _nativeContainerInfo : null;

    // // See ReactUpdateQueue
    // _pendingElement : null;
    // _pendingStateQueue : null;
    // _pendingReplaceState : false;
    // _pendingForceUpdate : false;

    // _renderedNodeType : null;
    // _renderedComponent : null;
    // _context : null;
    // _mountOrder : 0;
    // _topLevelWrapper : null;

    // // See ReactUpdates and ReactUpdateQueue.
    // _pendingCallbacks : null;

    // _mountIndex : 0,
    // _mountImage : null
    // }

    // The initial render is synchronous but any updates that happen during
    // rendering, in componentWillMount or componentDidMount, will be batched
    // according to the current batching strategy.

    ReactUpdates.batchedUpdates(
      batchedMountComponentIntoNode,
      componentInstance,
      container,
      shouldReuseMarkup,
      context
    );

    var wrapperID = componentInstance._instance.rootID;
    instancesByReactRootID[wrapperID] = componentInstance;

    return componentInstance;
  },
}

function batchedMountComponentIntoNode(
  componentInstance,
  container,
  shouldReuseMarkup,
  context
) {
  // ReactDOMFeatureFlags.useCreateElement默认为true
  var transaction = ReactUpdates.ReactReconcileTransaction.getPooled(
    /* useCreateElement */
    !shouldReuseMarkup && ReactDOMFeatureFlags.useCreateElement
  );
  // perform内部调用mountComponentIntoNode.call(
  //   null,
  //   componentInstance,
  //   container,
  //   transaction,
  //   null,
  //   null)
  transaction.perform(
    mountComponentIntoNode,
    null,
    componentInstance,
    container,
    transaction,
    shouldReuseMarkup,
    context
  );
  ReactUpdates.ReactReconcileTransaction.release(transaction);
}

function mountComponentIntoNode(
  wrapperInstance,
  container,
  transaction,
  shouldReuseMarkup,
  context
) {
  var markerName;
  // ReactFeatureFlags.logTopLevelRenders默认为false
  if (ReactFeatureFlags.logTopLevelRenders) {
    var wrappedElement = wrapperInstance._currentElement.props;
    var type = wrappedElement.type;
    markerName = 'React mount: ' + (
      typeof type === 'string' ? type :
      type.displayName || type.name
    );
    console.time(markerName);
  }

  var markup = ReactReconciler.mountComponent(
    wrapperInstance,
    transaction,
    null,
    ReactDOMContainerInfo(wrapperInstance, container),
    context
  );
//  var DOC_NODE_TYPE = 9;

// function ReactDOMContainerInfo(topLevelWrapper, node) {
//   var info = {
//     _topLevelWrapper: topLevelWrapper,
//     _idCounter: 1,
//     _ownerDocument: node ?
//       node.nodeType === DOC_NODE_TYPE ? node : node.ownerDocument :
//       null,
//     _tag: node ? node.nodeName.toLowerCase() : null,
//     _namespaceURI: node ? node.namespaceURI : null,
//   };
//   if (__DEV__) {
//     info._ancestorInfo = node ?
//       validateDOMNesting.updatedAncestorInfo(null, info._tag, null) : null;
//   }
//   return info;
// }

  if (markerName) {
    console.timeEnd(markerName);
  }

  wrapperInstance._renderedComponent._topLevelWrapper = wrapperInstance;
  ReactMount._mountImageIntoNode(
    markup,
    container,
    wrapperInstance,
    shouldReuseMarkup,
    transaction
  );
}

```

## [instantiateReactComponent.js](源码/src/renderers/shared/reconciler/instantiateReactComponent.js)部分代码如下：

```javascript

// To avoid a cyclic dependency, we create the final class in this module
var ReactCompositeComponentWrapper = function(element) {
  this.construct(element);
};
Object.assign(
  ReactCompositeComponentWrapper.prototype,
  ReactCompositeComponent.Mixin,
  {
    _instantiateReactComponent: instantiateReactComponent,
  }
);

/**
 * Check if the type reference is a known internal type. I.e. not a user
 * provided composite type.
 *
 * @param {function} type
 * @return {boolean} Returns true if this is a valid internal type.
 */
function isInternalComponentType(type) {
  return (
    typeof type === 'function' &&
    typeof type.prototype !== 'undefined' &&
    typeof type.prototype.mountComponent === 'function' &&
    typeof type.prototype.receiveComponent === 'function'
  );
}

/**
 * Given a ReactNode, create an instance that will actually be mounted.
 *
 * @param {ReactNode} node
 * @return {object} A new instance of the element's constructor.
 * @protected
 */
function instantiateReactComponent(node) {
  var instance;

  // 空组件
  if (node === null || node === false) {
    instance = ReactEmptyComponent.create(instantiateReactComponent);
  } else if (typeof node === 'object') {
    var element = node;

    // Special case string values
    if (typeof element.type === 'string') {
      // html标签
      instance = ReactNativeComponent.createInternalComponent(element);
    } else if (isInternalComponentType(element.type)) {
      // This is temporarily available for custom components that are not string
      // representations. I.e. ART. Once those are updated to use the string
      // representation, we can drop this code path.
      instance = new element.type(element);
    } else {
      // 自定义组件
      // src/renderers/shared/reconciler/ReactCompositeComponent.js
      instance = new ReactCompositeComponentWrapper(element);
      // 返回的实例
      // {
      //   _currentElement : {
      //   	$$typeof: Symbol.for('react.element'),
      //     type: TopLevelWrapper,
      //     key: null,
      //     ref: null,
      //     props: {$$typeof:Symbol.for('react.element'), type:App, key:null, ref:null, props:{}, _owner:null},
      //     _owner: null
      // };
      // _rootNodeID : null;
      // _instance : null;
      // _nativeParent : null;
      // _nativeContainerInfo : null;

      // // See ReactUpdateQueue
      // _pendingElement : null;
      // _pendingStateQueue : null;
      // _pendingReplaceState : false;
      // _pendingForceUpdate : false;

      // _renderedNodeType : null;
      // _renderedComponent : null;
      // _context : null;
      // _mountOrder : 0;
      // _topLevelWrapper : null;

      // // See ReactUpdates and ReactUpdateQueue.
      // _pendingCallbacks : null;
      // }
    }
  }
  // 文本组件
  else if (typeof node === 'string' || typeof node === 'number') {
    instance = ReactNativeComponent.createInstanceForText(node);
  } else {
    invariant(
      false,
      'Encountered invalid React node of type %s',
      typeof node
    );
  }

  // These two fields are used by the DOM and ART diffing algorithms
  // respectively. Instead of using expandos on components, we should be
  // storing the state needed by the diffing algorithms elsewhere.
  instance._mountIndex = 0;
  instance._mountImage = null;

  return instance;
}

module.exports = instantiateReactComponent;

```

## [ReactCompositeComponent.js](源码/src/renderers/shared/reconciler/ReactCompositeComponent.js)部分代码如下：

```javascript

var ReactCompositeComponentMixin = {

  /**
   * Base constructor for all composite component.
   *
   * @param {ReactElement} element
   * @final
   * @internal
   */
  construct: function(element) {
    this._currentElement = element;
    this._rootNodeID = null;
    this._instance = null;
    this._nativeParent = null;
    this._nativeContainerInfo = null;

    // See ReactUpdateQueue
    this._pendingElement = null;
    this._pendingStateQueue = null;
    this._pendingReplaceState = false;
    this._pendingForceUpdate = false;

    this._renderedNodeType = null;
    this._renderedComponent = null;
    this._context = null;
    this._mountOrder = 0;
    this._topLevelWrapper = null;

    // See ReactUpdates and ReactUpdateQueue.
    this._pendingCallbacks = null;
  },

  /**
   * Initializes the component, renders markup, and registers event listeners.
   *
   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
   * @param {?object} nativeParent
   * @param {?object} nativeContainerInfo
   * @param {?object} context
   * @return {?string} Rendered markup to be inserted into the DOM.
   * @final
   * @internal
   */
  mountComponent: function(
    transaction,
    nativeParent,
    nativeContainerInfo,
    context
  ) {
    this._context = context;
    this._mountOrder = nextMountID++;
    this._nativeParent = nativeParent;
    this._nativeContainerInfo = nativeContainerInfo;

    var publicProps = this._processProps(this._currentElement.props);
    var publicContext = this._processContext(context);

    var Component = this._currentElement.type;

    // Initialize the public class
    var inst;
    var renderedElement;

    if (Component.prototype && Component.prototype.isReactComponent) {
      inst = new Component(publicProps, publicContext, ReactUpdateQueue);
    } else {
      inst = Component(publicProps, publicContext, ReactUpdateQueue);
      
      if (inst == null || inst.render == null) {
        renderedElement = inst;
        inst = new StatelessComponent(Component);
      }
    }

    // These should be set up in the constructor, but as a convenience for
    // simpler class abstractions, we set them up after the fact.
    inst.props = publicProps;
    inst.context = publicContext;
    inst.refs = emptyObject;
    inst.updater = ReactUpdateQueue;

    this._instance = inst;

    // Store a reference from the instance back to the internal representation
    ReactInstanceMap.set(inst, this);

    var initialState = inst.state;
    if (initialState === undefined) {
      inst.state = initialState = null;
    }
    this._pendingStateQueue = null;
    this._pendingReplaceState = false;
    this._pendingForceUpdate = false;

    var markup;
    if (inst.unstable_handleError) {
      markup = this.performInitialMountWithErrorHandling(
        renderedElement,
        nativeParent,
        nativeContainerInfo,
        transaction,
        context
      );
    } else {
      markup = this.performInitialMount(renderedElement, nativeParent, nativeContainerInfo, transaction, context);
    }

    if (inst.componentDidMount) {
      transaction.getReactMountReady().enqueue(inst.componentDidMount, inst);
    }

    return markup;
  },
}

var ReactCompositeComponent = {

  Mixin: ReactCompositeComponentMixin,

};

module.exports = ReactCompositeComponent;

```

## [ReactUpdates.js](源码/src/renderers/shared/reconciler/ReactUpdates.js)部分代码如下：

```javascript

var dirtyComponents = [];
var asapCallbackQueue = CallbackQueue.getPooled();
var asapEnqueued = false;
var batchingStrategy = null;

var flushBatchedUpdates = function() {
  // ReactUpdatesFlushTransaction's wrappers will clear the dirtyComponents
  // array and perform any updates enqueued by mount-ready handlers (i.e.,
  // componentDidUpdate) but we need to check here too in order to catch
  // updates enqueued by setState callbacks and asap calls.
  while (dirtyComponents.length || asapEnqueued) {
    if (dirtyComponents.length) {
      var transaction = ReactUpdatesFlushTransaction.getPooled();
      transaction.perform(runBatchedUpdates, null, transaction);
      ReactUpdatesFlushTransaction.release(transaction);
    }

    if (asapEnqueued) {
      asapEnqueued = false;
      var queue = asapCallbackQueue;
      asapCallbackQueue = CallbackQueue.getPooled();
      queue.notifyAll();
      CallbackQueue.release(queue);
    }
  }
};

function batchedUpdates(callback, a, b, c, d, e) {
  batchingStrategy.batchedUpdates(callback, a, b, c, d, e);
}

var ReactUpdatesInjection = {
  injectBatchingStrategy: function(_batchingStrategy) {
    batchingStrategy = _batchingStrategy;
  },
};

var ReactUpdates = {
  batchedUpdates: batchedUpdates,
};

module.exports = ReactUpdates;

```

其中`batchingStrategy`是初始注入的`ReactDefaultBatchingStrategy`，此处实际上是在给真正需要执行的`callback`包裹`transaction`,目的是在执行`batchedMountComponentIntoNode`的前后分别执行`FLUSH_BATCHED_UPDATES`、`FLUSH_BATCHED_UPDATES`的`initialize`和`close`

## [ReactDefaultBatchingStrategy.js]((源码/src/renderers/shared/reconciler/ReactDefaultBatchingStrategy.js))代码如下：

```javascript

/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactDefaultBatchingStrategy
 */

'use strict';

var ReactUpdates = require('ReactUpdates');
var Transaction = require('Transaction');

var emptyFunction = require('emptyFunction');

var RESET_BATCHED_UPDATES = {
  initialize: emptyFunction,
  close: function() {
    ReactDefaultBatchingStrategy.isBatchingUpdates = false;
  },
};

var FLUSH_BATCHED_UPDATES = {
  initialize: emptyFunction,
  close: ReactUpdates.flushBatchedUpdates.bind(ReactUpdates),
};

var TRANSACTION_WRAPPERS = [FLUSH_BATCHED_UPDATES, RESET_BATCHED_UPDATES];

function ReactDefaultBatchingStrategyTransaction() {
  this.reinitializeTransaction();
}

Object.assign(
  ReactDefaultBatchingStrategyTransaction.prototype,
  Transaction.Mixin,
  {
    getTransactionWrappers: function() {
      return TRANSACTION_WRAPPERS;
    },
  }
);

var transaction = new ReactDefaultBatchingStrategyTransaction();

var ReactDefaultBatchingStrategy = {
  isBatchingUpdates: false,

  /**
   * Call the provided function in a context within which calls to `setState`
   * and friends are batched such that components aren't updated unnecessarily.
   */
  batchedUpdates: function(callback, a, b, c, d, e) {
    var alreadyBatchingUpdates = ReactDefaultBatchingStrategy.isBatchingUpdates;

    ReactDefaultBatchingStrategy.isBatchingUpdates = true;

    // The code is written this way to avoid extra allocations
    if (alreadyBatchingUpdates) {
      callback(a, b, c, d, e);
    } else {
      // 在perform内部执行callback.call(null,a,b,c,d,e)
      transaction.perform(callback, null, a, b, c, d, e);
    }
  },
};

module.exports = ReactDefaultBatchingStrategy;

```

## [ReactReconciler](源码/src/renderers/shared/reconciler/ReactReconciler.js)代码如下

```javascript

/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactReconciler
 */

'use strict';

var ReactRef = require('ReactRef');
var ReactInstrumentation = require('ReactInstrumentation');

/**
 * Helper to call ReactRef.attachRefs with this composite component, split out
 * to avoid allocations in the transaction mount-ready queue.
 */
function attachRefs() {
  ReactRef.attachRefs(this, this._currentElement);
}

var ReactReconciler = {

  /**
   * Initializes the component, renders markup, and registers event listeners.
   *
   * @param {ReactComponent} internalInstance
   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
   * @param {?object} the containing native component instance
   * @param {?object} info about the native container
   * @return {?string} Rendered markup to be inserted into the DOM.
   * @final
   * @internal
   */
  mountComponent: function(
    internalInstance,
    transaction,
    nativeParent,
    nativeContainerInfo,
    context
  ) {
    // internalInstance.mountComponent即为ReactCompositeComponent.mountComponent，参数分别为
    // new ReactReconcileTransaction(true)，
    // null,
    // ReactDOMContainerInfo(internalInstance, div#root)
    // null
    var markup = internalInstance.mountComponent(
      transaction,
      nativeParent,
      nativeContainerInfo,
      context
    );
    if (internalInstance._currentElement &&
        internalInstance._currentElement.ref != null) {
      transaction.getReactMountReady().enqueue(attachRefs, internalInstance);
    }
    if (__DEV__) {
      ReactInstrumentation.debugTool.onMountComponent(internalInstance);
    }
    return markup;
  },

  /**
   * Returns a value that can be passed to
   * ReactComponentEnvironment.replaceNodeWithMarkup.
   */
  getNativeNode: function(internalInstance) {
    return internalInstance.getNativeNode();
  },

  /**
   * Releases any resources allocated by `mountComponent`.
   *
   * @final
   * @internal
   */
  unmountComponent: function(internalInstance, safely) {
    ReactRef.detachRefs(internalInstance, internalInstance._currentElement);
    internalInstance.unmountComponent(safely);
    if (__DEV__) {
      ReactInstrumentation.debugTool.onUnmountComponent(internalInstance);
    }
  },

  /**
   * Update a component using a new element.
   *
   * @param {ReactComponent} internalInstance
   * @param {ReactElement} nextElement
   * @param {ReactReconcileTransaction} transaction
   * @param {object} context
   * @internal
   */
  receiveComponent: function(
    internalInstance, nextElement, transaction, context
  ) {
    var prevElement = internalInstance._currentElement;

    if (nextElement === prevElement &&
        context === internalInstance._context
      ) {
      // Since elements are immutable after the owner is rendered,
      // we can do a cheap identity compare here to determine if this is a
      // superfluous reconcile. It's possible for state to be mutable but such
      // change should trigger an update of the owner which would recreate
      // the element. We explicitly check for the existence of an owner since
      // it's possible for an element created outside a composite to be
      // deeply mutated and reused.

      // TODO: Bailing out early is just a perf optimization right?
      // TODO: Removing the return statement should affect correctness?
      return;
    }

    var refsChanged = ReactRef.shouldUpdateRefs(
      prevElement,
      nextElement
    );

    if (refsChanged) {
      ReactRef.detachRefs(internalInstance, prevElement);
    }

    internalInstance.receiveComponent(nextElement, transaction, context);

    if (refsChanged &&
        internalInstance._currentElement &&
        internalInstance._currentElement.ref != null) {
      transaction.getReactMountReady().enqueue(attachRefs, internalInstance);
    }

    if (__DEV__) {
      ReactInstrumentation.debugTool.onUpdateComponent(internalInstance);
    }
  },

  /**
   * Flush any dirty changes in a component.
   *
   * @param {ReactComponent} internalInstance
   * @param {ReactReconcileTransaction} transaction
   * @internal
   */
  performUpdateIfNecessary: function(
    internalInstance,
    transaction
  ) {
    internalInstance.performUpdateIfNecessary(transaction);
    if (__DEV__) {
      ReactInstrumentation.debugTool.onUpdateComponent(internalInstance);
    }
  },

};

module.exports = ReactReconciler;

```