demo代码如下：

```react
// index.js
import React from 'react'
import ReactDOM from 'react-dom'
import App from './App'

ReactDOM.render(<App/>,document.getElementById('root'))

// App.jsx
import React, { useState } from 'react'
import PageA from './PageA'
import PageB from './PageB'

class App extends React.Component{
    constructor(props) {
        super(props)
        this.state = {
            color: 'red'
        }
        this.setColor = this.setColor.bind(this)
    }
    setColor(color) {
        this.setState({color})
    }
    render() {
        const color = this.state.color
        return <div>
        <span style={{color}}>app</span>
        <PageA color={color} setColor={this.setColor}/>
        <PageB color={color}/>
    </div>
    }
}

// PageA.jsx
import React from 'react'

export default class PageA extends React.Component{
    render () {
        const {color,setColor} = this.props
        return <div style={{color}}>
        <h2>pageA</h2>
        <button onClick={()=>{setColor('red')}}>红色</button>
        <button onClick={()=>{setColor('black')}}>黑色</button>
    </div>
    }
}

// PageB.jsx
import React from 'react'

export default class PageB extends React.Component{
    constructor(props) {
        super(props)
        this.state = {
            color: props.color
        }
    }
    componentWillReceiveProps(props) {
      this.setState({
        color: props.color
    })
    }
    render () {
        const color = this.state.color
        return <div style={{color}}>
        <h2>pageB</h2>
        <button onClick={()=>{this.setState({color:'red'})}}>红色</button>
        <button onClick={()=>{this.setState({color:'black'})}}>黑色</button>
    </div>
    }
}
```

项目的入口`ReactDOM.render(<App/>,document.getElementById('root'))`，首先jsx文件通过babel预设`@babel/preset-react`进行语法解析，结果为`ReactDOM.render(React.createElement(App, null),document.getElementById('root'))`。

> `@babel/preset-react`预设（preset）始终包含以下插件：
>
> - [@babel/plugin-syntax-jsx](https://www.babeljs.cn/docs/babel-plugin-syntax-jsx)
> - [@babel/plugin-transform-react-jsx](https://www.babeljs.cn/docs/babel-plugin-transform-react-jsx)
> - [@babel/plugin-transform-react-display-name](https://www.babeljs.cn/docs/babel-plugin-transform-react-display-name)
>
> 如果开启了 `development` 参数，还将包含以下插件：
>
> Classic runtime adds:
>
> - [@babel/plugin-transform-react-jsx-self](https://www.babeljs.cn/docs/babel-plugin-transform-react-jsx-self)
> - [@babel/plugin-transform-react-jsx-source](https://www.babeljs.cn/docs/babel-plugin-transform-react-jsx-source)

先来看看`React.createElement(App, null)`的调用关系及结果：

```javascript
// src/isomorphic/react.js
var createElement = ReactElement.createElement;

var React = {
  // 省略其余代码
  createElement: createElement,
  // 省略其余代码
}

// src/isomorphic/classic/element/ReactElement.js
var ReactCurrentOwner = require('ReactCurrentOwner');

var warning = require('warning');
var canDefineProperty = require('canDefineProperty');
var REACT_ELEMENT_TYPE =
  (typeof Symbol === 'function' && Symbol.for && Symbol.for('react.element')) ||
  0xeac7;

var RESERVED_PROPS = {
  key: true,
  ref: true,
  __self: true,
  __source: true,
};

/**
 * Factory method to create a new React element. This no longer adheres to
 * the class pattern, so do not use new to call it. Also, no instanceof check
 * will work. Instead test $$typeof field against Symbol.for('react.element') to check
 * if something is a React Element.
 */
// 调用ReactElement(App,null,null,null,null,null,{})
var ReactElement = function(type, key, ref, self, source, owner, props) {
  var element = {
    // This tag allow us to uniquely identify this as a React Element
    // react通过$$typeof来表示一个对象是ReactElement对象，$$typeof的值为Symbol.for('react.element')) || 0xeac7
    $$typeof: REACT_ELEMENT_TYPE,

    // Built-in properties that belong on the element
    type: type,
    key: key,
    ref: ref,
    props: props,

    // Record the component responsible for creating this element.
    _owner: owner,
  };

  // 结果为 {$$typeof:Symbol.for('react.element'), type:App, key:null, ref:null, props:{}, _owner:null}
  return element;
};

// 调用ReactElement.createElement(App,null)
ReactElement.createElement = function(type, config, children) {
  var propName;

  // Reserved names are extracted
  var props = {};

  var key = null;
  var ref = null;
  var self = null;
  var source = null;

  // confing为null，所以这里跳过
  if (config != null) {
    if (__DEV__) {
      ref = !config.hasOwnProperty('ref') ||
        Object.getOwnPropertyDescriptor(config, 'ref').get ? null : config.ref;
      key = !config.hasOwnProperty('key') ||
        Object.getOwnPropertyDescriptor(config, 'key').get ? null : '' + config.key;
    } else {
      ref = config.ref === undefined ? null : config.ref;
      key = config.key === undefined ? null : '' + config.key;
    }
    self = config.__self === undefined ? null : config.__self;
    source = config.__source === undefined ? null : config.__source;
    // Remaining properties are added to a new props object
    for (propName in config) {
      if (config.hasOwnProperty(propName) &&
          !RESERVED_PROPS.hasOwnProperty(propName)) {
        props[propName] = config[propName];
      }
    }
  }

  // 没有children，所以这里跳过
  // Children can be more than one argument, and those are transferred onto
  // the newly allocated props object.
  var childrenLength = arguments.length - 2;
  if (childrenLength === 1) {
    props.children = children;
  } else if (childrenLength > 1) {
    var childArray = Array(childrenLength);
    for (var i = 0; i < childrenLength; i++) {
      childArray[i] = arguments[i + 2];
    }
    props.children = childArray;
  }

  // type是App，App本身没有defaultProps，但是
  // Resolve default props
  if (type && type.defaultProps) {
    var defaultProps = type.defaultProps;
    for (propName in defaultProps) {
      if (props[propName] === undefined) {
        props[propName] = defaultProps[propName];
      }
    }
  }
  // 结果为ReactElement(App,null,null,null,null,null,{})
  return ReactElement(
    type,
    key,
    ref,
    self,
    source,
    ReactCurrentOwner.current, // 初始为null
    props
  );
};

module.exports = ReactElement;

```

从上面的代码中可以看到，React源码中require()的参数都是直接写的文件名而不是相对或绝对路径，实现方式在[此处](./阅读记录/全局模块系统.md)讲解。

关于$$typeof的解析，在[这篇文章](./阅读记录/$$typeof.md)中。

最终得到的结果为`{$$typeof:Symbol.for('react.element'), type:App, key:null, ref:null, props:{}, _owner:null}`。

程序继续执行，现在的调用是`ReactDOM.render({$$typeof:Symbol.for('react.element'), type:App, key:null, ref:null, props:{}, _owner:null},document.getElementById('root'))`。

接下来看看`ReactDOM.render`的调用关系：

```javascript
// src/renderers/dom/ReactDOM.js

// 依赖注入
ReactDefaultInjection.inject();

var render = ReactPerf.measure('React', 'render', ReactMount.render);

var React = {
  findDOMNode: findDOMNode,
  render: render,
  unmountComponentAtNode: ReactMount.unmountComponentAtNode,
  version: ReactVersion,

  /* eslint-disable camelcase */
  unstable_batchedUpdates: ReactUpdates.batchedUpdates,
  unstable_renderSubtreeIntoContainer: renderSubtreeIntoContainer
  /* eslint-enable camelcase */
};
```

这里先进行了[依赖注入](./阅读记录/依赖注入.md)，然后调用`ReactMount.render`方法：

```javascript
// src/renderers/dom/client/ReactMount.js
var ELEMENT_NODE_TYPE = 1;
var DOC_NODE_TYPE = 9;
var DOCUMENT_FRAGMENT_NODE_TYPE = 11;
// container为div#root
function getReactRootElementInContainer(container) {
  if (!container) {
    return null;
  }
  // container为div#root,container.nodeType为1
  if (container.nodeType === DOC_NODE_TYPE) {
    return container.documentElement;
  } else {
    // container.firstChild为Null
    return container.firstChild;
  }
}
// container为div#root
function getNativeRootInstanceInContainer(container) {
  var rootEl = getReactRootElementInContainer(container);
  var prevNativeInstance =
    rootEl && ReactDOMComponentTree.getInstanceFromNode(rootEl);
  return (
    prevNativeInstance && !prevNativeInstance._nativeParent ?
    prevNativeInstance : null
  );
}
// container为div#root
function getTopLevelWrapperInContainer(container) {
  var root = getNativeRootInstanceInContainer(container);
  return root ? root._nativeContainerInfo._topLevelWrapper : null;
}

var topLevelRootCounter = 1;
var TopLevelWrapper = function() {
  this.rootID = topLevelRootCounter++;
};
TopLevelWrapper.prototype.isReactComponent = {};
if (__DEV__) {
  TopLevelWrapper.displayName = 'TopLevelWrapper';
}
TopLevelWrapper.prototype.render = function() {
  // this.props is actually a ReactElement
  return this.props;
};

var ReactMount = {
  TopLevelWrapper: TopLevelWrapper,
  // 调用ReactMount.render({$$typeof:Symbol.for('react.element'), type:App, key:null, ref:null, props:{}, _owner:null}, div#root)
  render: function(nextElement, container, callback) {
    return ReactMount._renderSubtreeIntoContainer(null, nextElement, container, callback);
  },
    
  _renderSubtreeIntoContainer: function(parentComponent, nextElement, container, callback) {
    ReactUpdateQueue.validateCallback(callback, 'ReactDOM.render');

    // 其中TopLevelWrapper定义如上，nextElement为{$$typeof:Symbol.for('react.element'), key:null, ref:null, props:{}, _owner:null}
    // 结果为{
      	$$typeof: Symbol.for('react.element'),
        type: TopLevelWrapper,
        key: null,
        ref: null,
        props: {$$typeof:Symbol.for('react.element'), type:App, key:null, ref:null, props:{}, _owner:null},
        _owner: null
  	// }
    var nextWrappedElement = ReactElement(
      TopLevelWrapper,
      null,
      null,
      null,
      null,
      null,
      nextElement
    );

    // container为div#root， 返回结果为null
    var prevComponent = getTopLevelWrapperInContainer(container);

    if (prevComponent) {
      var prevWrappedElement = prevComponent._currentElement;
      var prevElement = prevWrappedElement.props;
      if (shouldUpdateReactComponent(prevElement, nextElement)) {
        var publicInst = prevComponent._renderedComponent.getPublicInstance();
        var updatedCallback = callback && function() {
          callback.call(publicInst);
        };
        ReactMount._updateRootComponent(
          prevComponent,
          nextWrappedElement,
          container,
          updatedCallback
        );
        return publicInst;
      } else {
        ReactMount.unmountComponentAtNode(container);
      }
    }
	// 结果为null
    var reactRootElement = getReactRootElementInContainer(container);
    var containerHasReactMarkup =
      reactRootElement && !!internalGetID(reactRootElement);
    // 结果为undefined
    var containerHasNonRootReactChild = hasNonRootReactChild(container);

    var shouldReuseMarkup =
      containerHasReactMarkup &&
      !prevComponent &&
      !containerHasNonRootReactChild;
    // 调用ReactMount._renderNewRootComponent({
      	$$typeof: Symbol.for('react.element'),
        type: TopLevelWrapper,
        key: null,
        ref: null,
        props: {$$typeof:Symbol.for('react.element'), type:App, key:null, ref:null, props:{}, _owner:null},
        _owner: null
  	// }, div#root, null, null)
    var component = ReactMount._renderNewRootComponent(
      nextWrappedElement,
      container,
      shouldReuseMarkup,
      parentComponent != null ?
        parentComponent._reactInternalInstance._processChildContext(
          parentComponent._reactInternalInstance._context
        ) :
        emptyObject
    )._renderedComponent.getPublicInstance();
    if (callback) {
      callback.call(component);
    }
    return component;
  },
    
  _renderNewRootComponent: function(
    nextElement,
    container,
    shouldReuseMarkup,
    context
  ) {

    ReactBrowserEventEmitter.ensureScrollValueMonitoring();
    // 调用instantiateReactComponent({
      	$$typeof: Symbol.for('react.element'),
        type: TopLevelWrapper,
        key: null,
        ref: null,
        props: {$$typeof:Symbol.for('react.element'), type:App, key:null, ref:null, props:{}, _owner:null},
        _owner: null
  	// })
    var componentInstance = instantiateReactComponent(nextElement);

    // The initial render is synchronous but any updates that happen during
    // rendering, in componentWillMount or componentDidMount, will be batched
    // according to the current batching strategy.

    ReactUpdates.batchedUpdates(
      batchedMountComponentIntoNode,
      componentInstance,
      container,
      shouldReuseMarkup,
      context
    );

    var wrapperID = componentInstance._instance.rootID;
    instancesByReactRootID[wrapperID] = componentInstance;

    if (__DEV__) {
      ReactInstrumentation.debugTool.onMountRootComponent(componentInstance);
    }

    return componentInstance;
  },
}
```

```javascript
// src/renderers/shared/reconciler/instantiateReactComponent.js

// To avoid a cyclic dependency, we create the final class in this module
var ReactCompositeComponentWrapper = function(element) {
  this.construct(element);
};
Object.assign(
  ReactCompositeComponentWrapper.prototype,
  ReactCompositeComponent.Mixin,
  {
    _instantiateReactComponent: instantiateReactComponent,
  }
);

function getDeclarationErrorAddendum(owner) {
  if (owner) {
    var name = owner.getName();
    if (name) {
      return ' Check the render method of `' + name + '`.';
    }
  }
  return '';
}

/**
 * Check if the type reference is a known internal type. I.e. not a user
 * provided composite type.
 *
 * @param {function} type
 * @return {boolean} Returns true if this is a valid internal type.
 */
function isInternalComponentType(type) {
  return (
    typeof type === 'function' &&
    typeof type.prototype !== 'undefined' &&
    typeof type.prototype.mountComponent === 'function' &&
    typeof type.prototype.receiveComponent === 'function'
  );
}

/**
 * Given a ReactNode, create an instance that will actually be mounted.
 *
 * @param {ReactNode} node
 * @return {object} A new instance of the element's constructor.
 * @protected
 */
function instantiateReactComponent(node) {
  var instance;

  // 空组件
  if (node === null || node === false) {
    instance = ReactEmptyComponent.create(instantiateReactComponent);
  } else if (typeof node === 'object') {
    var element = node;

    // Special case string values
    if (typeof element.type === 'string') {
      // html标签
      instance = ReactNativeComponent.createInternalComponent(element);
    } else if (isInternalComponentType(element.type)) {
      // This is temporarily available for custom components that are not string
      // representations. I.e. ART. Once those are updated to use the string
      // representation, we can drop this code path.
      // web component
      instance = new element.type(element);
    } else {
      // 自定义组件
      instance = new ReactCompositeComponentWrapper(element);
    }
  }
  // 文本组件
  else if (typeof node === 'string' || typeof node === 'number') {
    instance = ReactNativeComponent.createInstanceForText(node);
  } else {
    invariant(
      false,
      'Encountered invalid React node of type %s',
      typeof node
    );
  }

  // These two fields are used by the DOM and ART diffing algorithms
  // respectively. Instead of using expandos on components, we should be
  // storing the state needed by the diffing algorithms elsewhere.
  instance._mountIndex = 0;
  instance._mountImage = null;

  return instance;
}

module.exports = instantiateReactComponent;

```

