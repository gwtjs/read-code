## 说明

前置部分基本与`react15`相同，因此直接从`ReactDOM.render`方法开始。

## 调用`ReactDOM.render`

```javascript
const ReactDOM = {
    
    render(
        element: React$Element<any>,
        container: DOMContainer,
        callback: ?Function,
    ) {
        return legacyRenderSubtreeIntoContainer(
            null,
            element,
            container,
            false,
            callback,
        );
    },
}

function legacyRenderSubtreeIntoContainer(
  parentComponent: ?React$Component<any, any>,
  children: ReactNodeList,
  container: DOMContainer,
  forceHydrate: boolean,
  callback: ?Function,
) {
  // TODO: Without `any` type, Flow says "Property cannot be accessed on any
  // member of intersection type." Whyyyyyy.
  let root: _ReactSyncRoot = (container._reactRootContainer: any);
  let fiberRoot;
  if (!root) {
    // Initial mount
    root = container._reactRootContainer = legacyCreateRootFromDOMContainer(
      container,
      forceHydrate,
    );
    fiberRoot = root._internalRoot;
    if (typeof callback === 'function') {
      const originalCallback = callback;
      callback = function() {
        const instance = getPublicRootInstance(fiberRoot);
        originalCallback.call(instance);
      };
    }
    // Initial mount should not be batched.
    unbatchedUpdates(() => {
      updateContainer(children, fiberRoot, parentComponent, callback);
    });
  } else {
    fiberRoot = root._internalRoot;
    if (typeof callback === 'function') {
      const originalCallback = callback;
      callback = function() {
        const instance = getPublicRootInstance(fiberRoot);
        originalCallback.call(instance);
      };
    }
    // Update
    updateContainer(children, fiberRoot, parentComponent, callback);
  }
  return getPublicRootInstance(fiberRoot);
}
```

### 初次渲染

#### 生成`FiberRootNode`

调用关系`legacyCreateRootFromDOMContainer`-->`ReactSyncRoot`-->`createRootImpl`-->`createContainer`-->`createFiberRoot`-->`new FiberNode && new FiberRootNode`

```javascript
function legacyCreateRootFromDOMContainer(
  container: DOMContainer,
  forceHydrate: boolean,
): _ReactSyncRoot {
  const shouldHydrate =
    forceHydrate || shouldHydrateDueToLegacyHeuristic(container);
  // First clear any existing content.
  if (!shouldHydrate) {
    let warned = false;
    let rootSibling;
    while ((rootSibling = container.lastChild)) {
      container.removeChild(rootSibling);
    }
  }

  // Legacy roots are not batched.
  return new ReactSyncRoot(
    container,
    LegacyRoot,
    shouldHydrate
      ? {
          hydrate: true,
        }
      : undefined,
  );
}

function ReactSyncRoot(
  container: DOMContainer,
  tag: RootTag,
  options: void | RootOptions,
) {
  this._internalRoot = createRootImpl(container, tag, options);
}

function createRootImpl(
  container: DOMContainer,
  tag: RootTag,
  options: void | RootOptions,
) {
  // Tag is either LegacyRoot or Concurrent Root
  const hydrate = options != null && options.hydrate === true;
  const hydrationCallbacks =
    (options != null && options.hydrationOptions) || null;
  const root = createContainer(container, tag, hydrate, hydrationCallbacks);
  markContainerAsRoot(root.current, container);
  if (hydrate && tag !== LegacyRoot) {
    const doc =
      container.nodeType === DOCUMENT_NODE
        ? container
        : container.ownerDocument;
    eagerlyTrapReplayableEvents(doc);
  }
  return root;
}

export function createContainer(
  containerInfo: Container,
  tag: RootTag,
  hydrate: boolean,
  hydrationCallbacks: null | SuspenseHydrationCallbacks,
): OpaqueRoot {
  return createFiberRoot(containerInfo, tag, hydrate, hydrationCallbacks);
}

export function createFiberRoot(
  containerInfo: any,
  tag: RootTag,
  hydrate: boolean,
  hydrationCallbacks: null | SuspenseHydrationCallbacks,
): FiberRoot {
  const root: FiberRoot = (new FiberRootNode(containerInfo, tag, hydrate): any);
  if (enableSuspenseCallback) {
    root.hydrationCallbacks = hydrationCallbacks;
  }

  // Cyclic construction. This cheats the type system right now because
  // stateNode is any.
  const uninitializedFiber = createHostRootFiber(tag);
  root.current = uninitializedFiber;
  uninitializedFiber.stateNode = root;

  return root;
}

export function createHostRootFiber(tag: RootTag): Fiber {
  let mode;
  if (tag === ConcurrentRoot) {
    mode = ConcurrentMode | BatchedMode | StrictMode;
  } else if (tag === BatchedRoot) {
    mode = BatchedMode | StrictMode;
  } else {
    mode = NoMode;
  }

  if (enableProfilerTimer && isDevToolsPresent) {
    // Always collect profile timings when DevTools are present.
    // This enables DevTools to start capturing timing at any point–
    // Without some nodes in the tree having empty base times.
    mode |= ProfileMode;
  }

  return createFiber(HostRoot, null, null, mode);
}

const createFiber = function(
  tag: WorkTag,
  pendingProps: mixed,
  key: null | string,
  mode: TypeOfMode,
): Fiber {
  // $FlowFixMe: the shapes are exact here but Flow doesn't like constructors
  return new FiberNode(tag, pendingProps, key, mode);
};

function FiberNode(
  tag: WorkTag,
  pendingProps: mixed,
  key: null | string,
  mode: TypeOfMode,
) {
  // Instance
  this.tag = tag;
  this.key = key;
  this.elementType = null;
  this.type = null;
  this.stateNode = null;

  // Fiber
  this.return = null;
  this.child = null;
  this.sibling = null;
  this.index = 0;

  this.ref = null;

  this.pendingProps = pendingProps;
  this.memoizedProps = null;
  this.updateQueue = null;
  this.memoizedState = null;
  this.dependencies = null;

  this.mode = mode;

  // Effects
  this.effectTag = NoEffect;
  this.nextEffect = null;

  this.firstEffect = null;
  this.lastEffect = null;

  this.expirationTime = NoWork;
  this.childExpirationTime = NoWork;

  this.alternate = null;

  if (enableProfilerTimer) {
    // Note: The following is done to avoid a v8 performance cliff.
    //
    // Initializing the fields below to smis and later updating them with
    // double values will cause Fibers to end up having separate shapes.
    // This behavior/bug has something to do with Object.preventExtension().
    // Fortunately this only impacts DEV builds.
    // Unfortunately it makes React unusably slow for some applications.
    // To work around this, initialize the fields below with doubles.
    //
    // Learn more about this here:
    // https://github.com/facebook/react/issues/14365
    // https://bugs.chromium.org/p/v8/issues/detail?id=8538
    this.actualDuration = Number.NaN;
    this.actualStartTime = Number.NaN;
    this.selfBaseDuration = Number.NaN;
    this.treeBaseDuration = Number.NaN;

    // It's okay to replace the initial doubles with smis after initialization.
    // This won't trigger the performance cliff mentioned above,
    // and it simplifies other profiler code (including DevTools).
    this.actualDuration = 0;
    this.actualStartTime = -1;
    this.selfBaseDuration = 0;
    this.treeBaseDuration = 0;
  }

  // This is normally DEV-only except www when it adds listeners.
  // TODO: remove the User Timing integration in favor of Root Events.
  if (enableUserTimingAPI) {
    this._debugID = debugCounter++;
    this._debugIsCurrentlyTiming = false;
  }
}

function FiberRootNode(containerInfo, tag, hydrate) {
  this.tag = tag;
  this.current = null;
  this.containerInfo = containerInfo;
  this.pendingChildren = null;
  this.pingCache = null;
  this.finishedExpirationTime = NoWork;
  this.finishedWork = null;
  this.timeoutHandle = noTimeout;
  this.context = null;
  this.pendingContext = null;
  this.hydrate = hydrate;
  this.firstBatch = null;
  this.callbackNode = null;
  this.callbackPriority = NoPriority;
  this.firstPendingTime = NoWork;
  this.firstSuspendedTime = NoWork;
  this.lastSuspendedTime = NoWork;
  this.nextKnownPendingLevel = NoWork;
  this.lastPingedTime = NoWork;
  this.lastExpiredTime = NoWork;

  if (enableSchedulerTracing) {
    this.interactionThreadID = unstable_getThreadID();
    this.memoizedInteractions = new Set();
    this.pendingInteractionMap = new Map();
  }
  if (enableSuspenseCallback) {
    this.hydrationCallbacks = null;
  }
}
```

#### 渲染

```javascript
export function unbatchedUpdates<A, R>(fn: (a: A) => R, a: A): R {
  const prevExecutionContext = executionContext;
  executionContext &= ~BatchedContext;
  executionContext |= LegacyUnbatchedContext;
  try {
    return fn(a);
  } finally {
    executionContext = prevExecutionContext;
    if (executionContext === NoContext) {
      // Flush the immediate callbacks that were scheduled during this batch
      flushSyncCallbackQueue();
    }
  }
}

export function updateContainer(
  element: ReactNodeList,
  container: OpaqueRoot,
  parentComponent: ?React$Component<any, any>,
  callback: ?Function,
): ExpirationTime {
  const current = container.current;
  const currentTime = requestCurrentTime();
    
  const suspenseConfig = requestCurrentSuspenseConfig();
  const expirationTime = computeExpirationForFiber(
    currentTime,
    current,
    suspenseConfig,
  );
  return updateContainerAtExpirationTime(
    element,
    container,
    parentComponent,
    expirationTime,
    suspenseConfig,
    callback,
  );
}

export function updateContainerAtExpirationTime(
  element: ReactNodeList,
  container: OpaqueRoot,
  parentComponent: ?React$Component<any, any>,
  expirationTime: ExpirationTime,
  suspenseConfig: null | SuspenseConfig,
  callback: ?Function,
) {
  // TODO: If this is a nested container, this won't be the root.
  const current = container.current;

  const context = getContextForSubtree(parentComponent);
  if (container.context === null) {
    container.context = context;
  } else {
    container.pendingContext = context;
  }

  return scheduleRootUpdate(
    current,
    element,
    expirationTime,
    suspenseConfig,
    callback,
  );
}

function scheduleRootUpdate(
  current: Fiber,
  element: ReactNodeList,
  expirationTime: ExpirationTime,
  suspenseConfig: null | SuspenseConfig,
  callback: ?Function,
) {
  const update = createUpdate(expirationTime, suspenseConfig);
  // Caution: React DevTools currently depends on this property
  // being called "element".
  update.payload = {element};

  callback = callback === undefined ? null : callback;
  if (callback !== null) {
    warningWithoutStack(
      typeof callback === 'function',
      'render(...): Expected the last optional `callback` argument to be a ' +
        'function. Instead received: %s.',
      callback,
    );
    update.callback = callback;
  }

  enqueueUpdate(current, update);
  scheduleWork(current, expirationTime);

  return expirationTime;
}
```



## 调用setState

[图片地址](https://github.com/gwtjs/read-code/raw/master/react15/%E5%9B%BE%E7%89%87/setState.svg)

<img src="https://github.com/gwtjs/read-code/raw/master/react15/%E5%9B%BE%E7%89%87/setState.svg" alt="injection"  />



首先不论是合成事件的回调方法还是生命周期方法中调用`setState`都会导致整个执行过程处于`ReactDefaultBatchingStrategyTransaction`中，在调用`setState`的时候，根据当前`batchingStrategy.isBatchingUpdates`状态决定是否马上执行更新还是当前`component`加入`dirtyComponents`进行批量更新。

而在类似`setTimeout`这种脱离了`ReactDefaultBatchingStrategyTransaction`的地方执行`setState`，由于`batchingStrategy.isBatchingUpdates`状态是`false`，因此这个时候的`setState`到得到新视图的过程既不批量、也不异步。

```javascript
function enqueueUpdate(component) {
  // componentWillMount在ReactDefaultBatchingStrategyTransaction的perform阶段执行，所以此时batchingStrategy.isBatchingUpdates为true
  // 因此此处执行dirtyComponents.push(component)
  if (!batchingStrategy.isBatchingUpdates) {
    batchingStrategy.batchedUpdates(enqueueUpdate, component);
    return;
  }

  dirtyComponents.push(component);
}
```

当`ReactDefaultBatchingStrategyTransaction`进入到执行`warppers`的`close`阶段时，其中`FLUSH_BATCHED_UPDATES`这个`warpper`的`close`方法调用`ReactUpdates.flushBatchedUpdates.bind(ReactUpdates)`由此进入批量更新阶段，遍历`dirtyComponents`进行更新。

在递归的过程中，组件的比较是通过`ReactElement`类型的实例进行的，如果`shouldUpdateReactComponent`的结果为false，则卸载原组件并重新生成，否则继续往下级递归。

```javascript
/**
 * Given a `prevElement` and `nextElement`, determines if the existing
 * instance should be updated as opposed to being destroyed or replaced by a new
 * instance. Both arguments are elements. This ensures that this logic can
 * operate on stateless trees without any backing instance.
 *
 * @param {?object} prevElement
 * @param {?object} nextElement
 * @return {boolean} True if the existing instance should be updated.
 * @protected
 */

function shouldUpdateReactComponent(prevElement, nextElement) {
  var prevEmpty = prevElement === null || prevElement === false;
  var nextEmpty = nextElement === null || nextElement === false;
  if (prevEmpty || nextEmpty) {
    return prevEmpty === nextEmpty;
  }

  var prevType = typeof prevElement;
  var nextType = typeof nextElement;
  if (prevType === 'string' || prevType === 'number') {
    return nextType === 'string' || nextType === 'number';
  } else {
    return nextType === 'object' && prevElement.type === nextElement.type && prevElement.key === nextElement.key;
  }
}
```

`ReactCompsiteComponent`类型组件将顺序调用`componentWillReciveProps`、`shouldUpdateComponent`、`componentWillUpdate`、`render`、`componentDidUpdate`生命周期方法

`ReactDOMCompoent`类型组件，首先进行属性的替换，替换方式为先删除后新增。然后根据`shouldUpdateReactComponent`方法判断继续向下递归（并且使用当前实例不重新创建）还是卸载当前实例并删除节点重新创建。完成之后，统一进行节点的新增、移动、删除操作。

```javascript
_updateChildren: function (nextNestedChildrenElements, transaction, context) {
      var prevChildren = this._renderedChildren;
      var removedNodes = {};
      var nextChildren = this._reconcilerUpdateChildren(prevChildren, 
        nextNestedChildrenElements, removedNodes, transaction, context);
      if (!nextChildren && !prevChildren) {
        return;
      }
      var updates = null;
      var name;
      // `nextIndex` will increment for each child in `nextChildren`, but
      // `lastIndex` will be the last index visited in `prevChildren`.
      var lastIndex = 0;
      var nextIndex = 0;
      var lastPlacedNode = null;
      for (name in nextChildren) {
        if (!nextChildren.hasOwnProperty(name)) {
          continue;
        }
        var prevChild = prevChildren && prevChildren[name];
        var nextChild = nextChildren[name];
        if (prevChild === nextChild) {
          updates = enqueue(updates, this.moveChild(prevChild, lastPlacedNode, nextIndex, lastIndex));
          lastIndex = Math.max(prevChild._mountIndex, lastIndex);
          prevChild._mountIndex = nextIndex;
        } else {
          if (prevChild) {
            // Update `lastIndex` before `_mountIndex` gets unset by unmounting.
            lastIndex = Math.max(prevChild._mountIndex, lastIndex);
            // The `removedNodes` loop below will actually remove the child.
          }
          // The child must be instantiated before it's mounted.
          updates = enqueue(updates, this._mountChildAtIndex(nextChild, lastPlacedNode, 
            nextIndex, transaction, context));
        }
        nextIndex++;
        lastPlacedNode = ReactReconciler.getNativeNode(nextChild);
      }
      // Remove children that are no longer present.
      for (name in removedNodes) {
        if (removedNodes.hasOwnProperty(name)) {
          updates = enqueue(updates, this._unmountChild(prevChildren[name], removedNodes[name]));
        }
      }
      if (updates) {
        processQueue(this, updates);
      }
      this._renderedChildren = nextChildren;
    },
```



## 疑惑点解答

### 在`componentWillMount`的时候调用`setState(newState)`会有什么表现？

`newState`会被合并。以下是`componentWillMount`被调用的相关代码：

```javascript
 performInitialMount: function (renderedElement, nativeParent, nativeContainerInfo, transaction, context) {
    var inst = this._instance;
    if (inst.componentWillMount) {
      inst.componentWillMount();
      // When mounting, calls to `setState` by `componentWillMount` will set
      // `this._pendingStateQueue` without triggering a re-render.
      if (this._pendingStateQueue) {
        inst.state = this._processPendingState(inst.props, inst.context);
      }
    }
    // 其余代码省略
 }

// 调用setState时，执行以下代码
enqueueSetState: function (publicInstance, partialState) {
    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'setState');

    if (!internalInstance) {
        return;
    }
	// 新的state被push到_pendingStateQueue中
    var queue = internalInstance._pendingStateQueue || (internalInstance._pendingStateQueue = []);
    queue.push(partialState);

    enqueueUpdate(internalInstance);
}

_processPendingState: function (props, context) {
    var inst = this._instance;
    var queue = this._pendingStateQueue;
    var replace = this._pendingReplaceState;
    this._pendingReplaceState = false;
    this._pendingStateQueue = null;

    if (!queue) {
        return inst.state;
    }

    if (replace && queue.length === 1) {
        return queue[0];
    }

    var nextState = _assign({}, replace ? queue[0] : inst.state);
    for (var i = replace ? 1 : 0; i < queue.length; i++) {
        var partial = queue[i];
        _assign(nextState, typeof partial === 'function' ? partial.call(inst, nextState, props, context) : partial);
    }

    return nextState;
},

```

从以上代码中可以看到，如果在`componentWillMount`中调用`setState(newState)`方法，那么`newState`会被push到`this._pendingStateQueue`中，从而在`this._processPendingState`方法中，最后导致`inst`的`state`被设置为`this._processPendingState(inst.props, inst.context)`的结果。

这里还有个问题是，虽然`newState`被合并了，但是`enqueueUpdate`的执行会导致当前`inst`被push到`dirtyCompnent`中，那么为什么没有造成组件的重新渲染呢？代码如下

```javascript
function enqueueUpdate(component) {
  // componentWillMount在ReactDefaultBatchingStrategyTransaction的perform阶段执行，所以此时batchingStrategy.isBatchingUpdates为true
  // 因此此处执行dirtyComponents.push(component)
  if (!batchingStrategy.isBatchingUpdates) {
    batchingStrategy.batchedUpdates(enqueueUpdate, component);
    return;
  }

  dirtyComponents.push(component);
}
```

当组件渲染完成之后，`ReactDefaultBatchingStrategyTransaction`顺序执行所有`warpper`的`close`方法，其中`FLUSH_BATCHED_UPDATES`这个`warpper`的`close`方法调用`ReactUpdates.flushBatchedUpdates.bind(ReactUpdates)`

```javascript
var flushBatchedUpdates = function () {
  while (dirtyComponents.length || asapEnqueued) {
    if (dirtyComponents.length) {
      var transaction = ReactUpdatesFlushTransaction.getPooled();
      // 存在dirtyComponents则执行runBatchedUpdates，transaction的warppers暂且不论
      transaction.perform(runBatchedUpdates, null, transaction);
      ReactUpdatesFlushTransaction.release(transaction);
    }
	// 省略其他代码
  }
};

function runBatchedUpdates(transaction) {
  var len = transaction.dirtyComponentsLength;
  dirtyComponents.sort(mountOrderComparator);

  // 遍历dirtyComponents，执行ReactReconciler.performUpdateIfNecessary
  for (var i = 0; i < len; i++) {
    var component = dirtyComponents[i];
    var callbacks = component._pendingCallbacks;
    component._pendingCallbacks = null;

    ReactReconciler.performUpdateIfNecessary(component, transaction.reconcileTransaction);

    if (callbacks) {
      for (var j = 0; j < callbacks.length; j++) {
        transaction.callbackQueue.enqueue(callbacks[j], component.getPublicInstance());
      }
    }
  }
}

performUpdateIfNecessary: function (transaction) {
    // 默认为null，在enqueueElementInternal调用中赋值，在receiveComponent、unmountComponent中被重置为null
    if (this._pendingElement != null) {
        ReactReconciler.receiveComponent(this, this._pendingElement, transaction, this._context);
    }
	// _pendingStateQueue在enqueueReplaceState、enqueueSetState中被赋值，在mountComponent、_processPendingState、unmountComponent中被重置为null
    // _pendingForceUpdate在enqueueForceUpdate中被赋值true，在mountComponent、updateComponent、unmountComponent中被重置为false
    if (this._pendingStateQueue !== null || this._pendingForceUpdate) {
        this.updateComponent(transaction, this._currentElement, this._currentElement, this._context, this._context);
    }
},
```

由此可知，如果在`componentWillMount`中调用了`setState`的话，虽然组件被`push`到`dirtyComponents`中但因为执行了`_processPendingState()`，该方法重置了`_pendingStateQueue`，因此最终并不会调用`updateComponent`导致重新渲染。

### 为什么在`render()`中调用`setState()`会造成无限循环，但在`componentDidMount`中调用却不会？

从上一个问题中我们知道`componentWillMount`在`ReactDefaultBatchingStrategyTransaction`的`perform`阶段执行，在方法内部调用`setState`的话，会导致当前组件被`push`到`dirtyComponents`组件中。

`render`方法与`componentWillMount`一样，在方法内部调用`setState`的话，会导致当前组件被`push`到`dirtyComponents`组件中。但是执行完`render`之后，到`ReactDefaultBatchingStrategyTransaction`调用`close`方法之前，`_pendingStateQueue`没有被重置，因此会调用`updateComponent`，从而导致`render`被循环调用。

`componentDidMount`则不同，它并没有直接执行，而是被加入到了`ReactReconcileTransaction`实例的`reactMountReady`属性的`_callbacks`队列中，并在该`transaction`的`close`执行阶段被执行。

在`componentDidMount`方法内部调用`setState`的话，会导致当前组件被`push`到`dirtyComponents`组件中。

但由于在`updateComponent`的调用链中不会再调用`componentDidMount`，因此它更新了组件却没有造成循环调用的问题。

```javascript
function batchedMountComponentIntoNode(componentInstance, container, shouldReuseMarkup, context) {
  var transaction = ReactUpdates.ReactReconcileTransaction.getPooled(
  /* useCreateElement */
  !shouldReuseMarkup && ReactDOMFeatureFlags.useCreateElement);
  // 此处调用ON_DOM_READY_QUEUEING的close时，调用CallbackQueue的notifyAll方法遍历执行_callbacks
  transaction.perform(mountComponentIntoNode, null, componentInstance, container, transaction, shouldReuseMarkup, context);
  ReactUpdates.ReactReconcileTransaction.release(transaction);
}
mountComponent: function (transaction, nativeParent, nativeContainerInfo, context) {
    // 忽略其他代码
    // 此处的transaction为ReactReconcileTransaction
    if (inst.componentDidMount) {
        transaction.getReactMountReady().enqueue(inst.componentDidMount, inst);
    }

    return markup;
},

function ReactReconcileTransaction(useCreateElement) {
  this.reinitializeTransaction();
  // Only server-side rendering really needs this option (see
  // `ReactServerRendering`), but server-side uses
  // `ReactServerRenderingTransaction` instead. This option is here so that it's
  // accessible and defaults to false when `ReactDOMComponent` and
  // `ReactTextComponent` checks it in `mountComponent`.`
  this.renderToStaticMarkup = false;
  // 这里最终为new CallbackQueue(null)
  this.reactMountReady = CallbackQueue.getPooled(null);
  this.useCreateElement = useCreateElement;
}
getReactMountReady: function () {
    return this.reactMountReady;
},
enqueue: function (callback, context) {
    this._callbacks = this._callbacks || [];
    this._contexts = this._contexts || [];
    this._callbacks.push(callback);
    this._contexts.push(context);
},
var ON_DOM_READY_QUEUEING = {
  /**
   * Initializes the internal `onDOMReady` queue.
   */
  initialize: function () {
    this.reactMountReady.reset();
  },

  /**
   * After DOM is flushed, invoke all registered `onDOMReady` callbacks.
   */
  close: function () {
    this.reactMountReady.notifyAll();
  }
};
    
function CallbackQueue() {
  this._callbacks = null;
  this._contexts = null;
}
notifyAll: function () {
    var callbacks = this._callbacks;
    var contexts = this._contexts;
    if (callbacks) {
        !(callbacks.length === contexts.length) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Mismatched list of contexts in callback queue') : invariant(false) : void 0;
        this._callbacks = null;
        this._contexts = null;
        for (var i = 0; i < callbacks.length; i++) {
            callbacks[i].call(contexts[i]);
        }
        callbacks.length = 0;
        contexts.length = 0;
    }
},
PooledClass.addPoolingTo(CallbackQueue);
var addPoolingTo = function (CopyConstructor, pooler) {
  var NewKlass = CopyConstructor;
  NewKlass.instancePool = [];
  // DEFAULT_POOLER = oneArgumentPooler
  NewKlass.getPooled = pooler || DEFAULT_POOLER;
  if (!NewKlass.poolSize) {
    NewKlass.poolSize = DEFAULT_POOL_SIZE;
  }
  NewKlass.release = standardReleaser;
  return NewKlass;
};
var oneArgumentPooler = function (copyFieldsFrom) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, copyFieldsFrom);
    return instance;
  } else {
    return new Klass(copyFieldsFrom);
  }
};
```



### 为什么说`setState()`状态更新是异步的？

`ReactDefaultBatchingStrategyTransaction.perform`期间调用`setState()`时，`state`都放入`_pendingStateQueue`中，`inst`都放入`dirtyComponents`中，并在`transaction`的`close`阶段合并`state`并更新所有`dirtyComponents`

因此从结果看，`setState`看起来是异步的，但实际上并不是在下一个事件循环中执行，而是通过`transaction`的控制实现的。

假如让`setState`脱离`transaction`的控制，就可以看到实际上`setState`是同步的，下面是个例子：

```javascript
import React, { useState } from './modules/React'
import {hot} from "react-hot-loader";
import PageA from './PageA'
import PageB from './PageB'

class App extends React.Component{
    constructor(props) {
        super(props)
        this.state = {
            color: 'red'
        }
        this.setColor = this.setColor.bind(this)
    }
    setColor(color) {
        this.setState({color})
        // 输出原来的值，而非传入的color
        console.log(this.state.color)
        setTimeout(()=>{
            this.setState({color:'green'})
            // 输出 green
            console.log(this.state.color);
            this.setState({color:'gray'})
            // 输出 gray
            console.log(this.state.color);
        })
    }
    componentDidMount(){
        this.setState({color:'orange'})
        // 输出 red
        console.log('componentDidMount',this.state.color);
        setTimeout(()=>{
            this.setState({color:'#00ff00'})
            // 输出 #00ff00
            console.log('componentDidMount',this.state.color);
        })

    }
    render() {
        const color = this.state.color
        return <div>
        <span style={{color}}>app</span>
        <PageA color={color} setColor={this.setColor}/>
        <PageB color={color}/>
    </div>
    }
}

export default App
```



### 为什么连续调用`setState()`会被合并？

`ReactDefaultBatchingStrategyTransaction.perform`期间存在多次`setState()`调用时，`state`都放入`_pendingStateQueue`中，并在`updateComponent`时调用`_processPendingState`进行合并。

假如让`setState`脱离`transaction`的控制，就不会存在合并更新的现象。

```javascript
_processPendingState: function (props, context) {
    var inst = this._instance;
    var queue = this._pendingStateQueue;
    var replace = this._pendingReplaceState;
    this._pendingReplaceState = false;
    this._pendingStateQueue = null;

    if (!queue) {
        return inst.state;
    }

    if (replace && queue.length === 1) {
        return queue[0];
    }

    var nextState = _assign({}, replace ? queue[0] : inst.state);
    for (var i = replace ? 1 : 0; i < queue.length; i++) {
        var partial = queue[i];
        _assign(nextState, typeof partial === 'function' ? partial.call(inst, nextState, props, context) : partial);
    }

    return nextState;
},
```



### 在P->A、P->B模型中，P存在名为p的state，P、A都使用了该state，但B未使用，p改变时，B会重新渲染吗？为什么？

会，根据react的更新机制，P的状态改变将会递归遍历所有子节点进行更新操作。详见[调用setState](#调用setState)图中的`updateComponent`方法。

   

## 总结

总的来说，react在管理一个树形数据，这个数据的关键属性如下

```javascript
{
	inst: 实例（如new App()），
	_nativeNode: 真实DOM节点, 
    _renderedComponent/renderedChildern: 关联下级数据,
    _currentElement: 虚拟DOM
}
```



文章主要包含了`jsx`编译、生命周期、依赖注入、事务、状态更新机制等内容的源码阅读。通过阅读这部分源码，对`React`如何将`jsx`文件最终转化为浏览器可识别并渲染的元素，更新数据时如何更新视图都有了比较全面的了解。

与此同时，也学习到了代码中所用到的依赖注入、工厂方法创建实例、事务、队列的使用等编码技巧。

相对来说`react`源码较难阅读，是由于其抽象程度较高的原因。而抽象是为了更好的复用，由于`react`中包含了浏览器端、服务器端、移动端等多种平台的需求，因此它的具有共性的核心内容就需要抽象出来，包括虚拟`DOM`很大程度都是因此引入的。

暂未关注的内容还有ref、context、合成事件等，后续再补充。

